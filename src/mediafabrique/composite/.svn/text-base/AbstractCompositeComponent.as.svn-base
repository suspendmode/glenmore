/**
 * Copyright (C) Piotr Kucharski
 * email: suspendmode@gmail.com
 *
 * All rights reserved. Any use, copying, modification, distribution and selling
 * of this software and it's documentation for any purposes without authors' written
 * permission is hereby prohibited.
 */
package patterns.structural.composite {
  import flash.events.Event;
  import flash.events.IEventDispatcher;
  import flash.utils.Dictionary;
  
  import logging.ILogger;
  import logging.Log;
  
  /**
   *
   */
  [Event(name="componentRemoved", type="composite.ContainerEvent")]
  
  /**
   *
   */
  [Event(name="componentAdded", type="composite.ContainerEvent")]
  
  /**
   *
   * @author piku
   *
   */
  public class AbstractCompositeComponent extends AbstractComponent implements ICompositeComponent {
    
    /**
     *
     */
    private static var log : ILogger = Log.getLogger(AbstractCompositeComponent);
    
    /**
     *
     * @param id
     * @param eventDispatcher
     *
     */
    public function AbstractCompositeComponent(id : String = null,
      eventDispatcher : IEventDispatcher = null) {
      super(id, eventDispatcher);
    }
    
    // ICompositeComponent impl
    
    /**
     *
     */
    private var _map : Dictionary;
    
    /**
     *
     * @param value
     *
     */
    public function set map(value : Dictionary) : void {
      _map = Dictionary(value);
    }
    
    /**
     *
     * @return
     *
     */
    public function get map() : Dictionary {
      if (!_map) {
        _map = new Dictionary();
      }
      return _map;
    }
    
    /**
     *
     * @return
     *
     */
    public function toArray() : Array {
      var list : Array = [];
      
      for each (var component : IComponent in list) {
        list.push(component);
      }
      return list;
    }
    
    // IComponentList impl
    
    // IContainer impl
    
    /**
     *
     */
    public var objects : Dictionary = new Dictionary();
    
    /**
     *
     * adds object with given name
     *
     * @param object Object instance of business object to register
     * @param name String name of business object
     *
     */
    public function add(object : Object, name : String) : void {
      objects[name] = object;
      log.info("{0} object added {1} with name {2}", this, object, name);
      dispatchEvent(new CompositeComponentEvent(CompositeComponentEvent.COMPONENT_ADDED, object,
        name));
    }
    
    /**
     *
     * @param object
     *
     */
    public function remove(object : Object) : void {
      var name : String = getName(object);
      removeByName(name);
    }
    
    /**
     *
     * @param name
     *
     */
    public function removeByName(name : String) : void {
      var object : Object = get(name);
      log.info("{0} object {1} with name {2} removed", this, object, name);
      delete objects[name];
      dispatchEvent(new CompositeComponentEvent(CompositeComponentEvent.COMPONENT_REMOVED, object,
        name));
    }
    
    /**
     *
     * @param object
     * @return
     *
     */
    public function getName(object : Object, throwsException : Boolean = false) : String {
      for (var name : * in objects) {
        var item : Object = objects[name];
        
        if (item === object) {
          return name;
        }
      }
      
      if (throwsException) {
        throw new Error("object " + object + " not found");
      } else {
        return null;
      }
    }
    
    
    /**
     *
     * @param type
     * @return
     *
     */
    public function getByType(type : Class, throwsException : Boolean = false) : * {
      for each (var object : * in objects) {
        if (object is type) {
          return object;
        }
      }
      
      if (throwsException) {
        throw new Error("object with type " + type + " not found");
      } else {
        return null;
      }
    }
    
    /**
     * Returns object by name
     *
     * @param name String name of business object
     * @return Object instance of business object
     *
     */
    public function get(name : String, throwsException : Boolean = false) : * {
      if (name in objects) {
        return objects[name];
      } else {
        if (throwsException) {
          throw new Error("object with " + name + " not found");
        } else {
          return null;
        }
      }
    }
    
    
    
    // EventBubbling
    
    override public function dispatchEvent(event : Event) : Boolean {
      var dispatched : Boolean = super.dispatchEvent(event);
      
      if (event is PropagableEvent) {
        for (var name : * in objects) {
          var object : Object = objects[name];
          log.info("{0} event {1} is propagated to {2}", this, event, object);
          
          if (object is IEventDispatcher) {
            IEventDispatcher(object).dispatchEvent(event);
          }
        }
      }
      return dispatched;
    }       
  }
}